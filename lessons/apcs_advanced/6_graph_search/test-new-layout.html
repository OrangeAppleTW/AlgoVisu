<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFSæ¼”ç®—æ³•æ¸¬è©¦ - æ–°ä½ˆå±€</title>
    <link rel="stylesheet" href="../../../styles/styles.css">
    <link rel="stylesheet" href="styles/graph-search.css">
    <style>
        /* ç°¡å–®çš„æ¸¬è©¦æ¨£å¼ */
        body { 
            padding: 20px; 
            font-family: Arial, sans-serif;
        }
        .test-container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .layout-info {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>ğŸ§ª BFS æ¼”ç®—æ³•æ¸¬è©¦é é¢ - æ–°æŠ•å½±ç‰‡ä½ˆå±€</h1>
        
        <div class="layout-info">
            <h3>ğŸ“ åœ–å½¢ä½ˆå±€èªªæ˜</h3>
            <p><strong>æŒ‰ç…§æŠ•å½±ç‰‡è¨­è¨ˆï¼š</strong></p>
            <ul>
                <li><strong>S</strong>ï¼šä¸­å¤®èµ·å§‹ç¯€é»</li>
                <li><strong>A</strong>ï¼šä¸­å·¦ä¸‹ä½ç½®ï¼ˆSçš„å­ç¯€é»ï¼‰</li>
                <li><strong>B</strong>ï¼šå³ä¸Šä½ç½®ï¼ˆSçš„å­ç¯€é»ï¼‰</li>
                <li><strong>C</strong>ï¼šå·¦ä¸‹ä½ç½®ï¼ˆAçš„å­ç¯€é»ï¼‰</li>
                <li><strong>D</strong>ï¼šä¸­ä¸‹ä½ç½®ï¼ˆBçš„å­ç¯€é»ï¼‰</li>
                <li><strong>E</strong>ï¼šå³ä¸‹ä½ç½®ï¼ˆBçš„å­ç¯€é»ï¼‰</li>
                <li><strong>F</strong>ï¼šå·¦ä¸Šä½ç½®ï¼ˆCçš„å­ç¯€é»ï¼‰</li>
            </ul>
            <p><strong>é€£æ¥é—œä¿‚ï¼š</strong>Sâ†’A, Sâ†’B, Aâ†’C, Bâ†’D, Bâ†’E, Câ†’F, Câ†’A(å›é€£)</p>
        </div>
        
        <div class="test-section">
            <h2>åœ–å½¢èˆ‡ä½‡åˆ—è¦–è¦ºåŒ–</h2>
            
            <div class="visualization-container">
                <div class="graph-area">
                    <h4>åœ–å½¢çµæ§‹</h4>
                    <svg id="bfs-graph" class="graph-svg"></svg>
                </div>
                <div class="queue-area">
                    <h4>Queue (ä½‡åˆ—) ç‹€æ…‹</h4>
                    <div id="bfs-queue" class="queue-container">
                        <div class="queue-label">Queue:</div>
                        <div class="queue-items"></div>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <button class="btn" id="bfs-start">é–‹å§‹ BFS</button>
                <button class="btn btn-secondary" id="bfs-step">å–®æ­¥åŸ·è¡Œ</button>
                <button class="btn btn-secondary" id="bfs-reset">é‡ç½®</button>
                <button class="btn btn-secondary" id="bfs-random">éš¨æ©Ÿåœ–å½¢</button>
            </div>

            <div class="speed-control">
                <label for="bfs-speed">åŸ·è¡Œé€Ÿåº¦ï¼š</label>
                <input type="range" id="bfs-speed" class="speed-slider" min="1" max="10" value="5">
                <span>å¿«</span>
            </div>

            <div class="status-display" id="bfs-status">
                é»æ“Šã€Œé–‹å§‹ BFSã€é–‹å§‹æœå°‹æ¼”ç®—æ³•æ¼”ç¤º
            </div>

            <div class="visit-order">
                <h4>è¨ªå•é †åºï¼š</h4>
                <div id="bfs-visit-order" class="visit-sequence"></div>
            </div>

            <div class="legend-container">
                <div class="legend-item">
                    <div class="legend-color default"></div>
                    <span>æœªè¨ªå•</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color in-queue"></div>
                    <span>åœ¨ä½‡åˆ—ä¸­</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color current"></div>
                    <span>ç•¶å‰è™•ç†</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color visited"></div>
                    <span>å·²è¨ªå•</span>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>å‹•æ…‹æ¨™ç±¤æ¸¬è©¦è¨˜éŒ„</h2>
            <div id="test-log" style="background: #f5f5f5; padding: 15px; border-radius: 4px; font-family: monospace; white-space: pre-line; max-height: 200px; overflow-y: auto;">
                æ­£åœ¨åˆå§‹åŒ–æ¸¬è©¦ç’°å¢ƒ...
            </div>
        </div>
    </div>

    <!-- JavaScript æª”æ¡ˆ -->
    <script src="scripts/graph-structure.js"></script>
    <script src="scripts/bfs-algorithm.js"></script>
    <script>
        // æ¸¬è©¦æ—¥èªŒå‡½æ•¸
        function log(message) {
            const logElement = document.getElementById('test-log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        // ç°¡åŒ–çš„ UI æ§åˆ¶å™¨ç”¨æ–¼æ¸¬è©¦
        class TestUI {
            constructor() {
                log('é–‹å§‹åˆå§‹åŒ–æ¸¬è©¦ UI...');
                this.initializeComponents();
                this.setupEventListeners();
                log('æ¸¬è©¦ UI åˆå§‹åŒ–å®Œæˆ');
            }

            initializeComponents() {
                try {
                    // åœ–å½¢çµæ§‹
                    this.graph = new GraphStructure();
                    this.graph.initializeGraph();
                    log('âœ“ åœ–å½¢çµæ§‹åˆå§‹åŒ–æˆåŠŸ - æ–°æŠ•å½±ç‰‡ä½ˆå±€');

                    // BFS å…ƒä»¶
                    this.bfsSvgRenderer = new TestSVGRenderer('bfs-graph', this.graph);
                    this.bfsQueueRenderer = new TestQueueRenderer('bfs-queue');
                    this.bfsAlgorithm = new BFSAlgorithm(this.graph, this.bfsSvgRenderer, this.bfsQueueRenderer);
                    log('âœ“ BFS æ¼”ç®—æ³•çµ„ä»¶åˆå§‹åŒ–æˆåŠŸ');

                    // åˆå§‹æ¸²æŸ“
                    this.bfsSvgRenderer.render();
                    log('âœ“ åˆå§‹åœ–å½¢æ¸²æŸ“å®Œæˆ - é¡¯ç¤ºæŠ•å½±ç‰‡ä½ˆå±€');
                    
                    // é¡¯ç¤ºç¯€é»ä¿¡æ¯
                    this.logNodePositions();
                } catch (error) {
                    log(`âœ— åˆå§‹åŒ–éŒ¯èª¤: ${error.message}`);
                    console.error('åˆå§‹åŒ–éŒ¯èª¤:', error);
                }
            }

            logNodePositions() {
                log('--- ç¯€é»ä½ç½®ä¿¡æ¯ ---');
                this.graph.getNodes().forEach(node => {
                    log(`${node.id}: (${node.x}, ${node.y}) - ${node.label || '(ç„¡æ¨™ç±¤)'}`);
                });
                log('--- é‚Šç·šé€£æ¥ä¿¡æ¯ ---');
                this.graph.getEdges().forEach(edge => {
                    log(`${edge.from} â†’ ${edge.to}`);
                });
            }

            setupEventListeners() {
                try {
                    document.getElementById('bfs-start')?.addEventListener('click', () => {
                        log('é–‹å§‹åŸ·è¡Œ BFS æ¼”ç®—æ³• - æŠ•å½±ç‰‡ä½ˆå±€');
                        this.bfsAlgorithm.start();
                    });

                    document.getElementById('bfs-step')?.addEventListener('click', () => {
                        log('åŸ·è¡Œ BFS å–®æ­¥');
                        this.bfsAlgorithm.step();
                    });

                    document.getElementById('bfs-reset')?.addEventListener('click', () => {
                        log('é‡ç½® BFS æ¼”ç®—æ³• - æ¸…ç©ºå‹•æ…‹æ¨™ç±¤');
                        this.bfsAlgorithm.reset();
                    });

                    document.getElementById('bfs-random')?.addEventListener('click', () => {
                        log('ç”Ÿæˆéš¨æ©Ÿè¨ªå•é †åº');
                        this.graph.generateRandomGraph();
                        this.bfsSvgRenderer.render();
                        this.bfsAlgorithm.reset();
                    });

                    document.getElementById('bfs-speed')?.addEventListener('input', (e) => {
                        const speed = parseInt(e.target.value);
                        log(`èª¿æ•´åŸ·è¡Œé€Ÿåº¦: ${speed}`);
                        this.bfsAlgorithm.setSpeed(speed);
                    });

                    log('âœ“ äº‹ä»¶ç›£è½å™¨è¨­ç½®å®Œæˆ');
                } catch (error) {
                    log(`âœ— äº‹ä»¶ç›£è½å™¨è¨­ç½®éŒ¯èª¤: ${error.message}`);
                    console.error('äº‹ä»¶ç›£è½å™¨éŒ¯èª¤:', error);
                }
            }
        }

        // æ¸¬è©¦ç”¨çš„ç°¡åŒ–æ¸²æŸ“å™¨
        class TestSVGRenderer {
            constructor(svgId, graph) {
                this.svg = document.getElementById(svgId);
                this.graph = graph;
                this.setupSVG();
            }

            setupSVG() {
                if (!this.svg) return;
                this.svg.innerHTML = '';
                this.svg.setAttribute('viewBox', '0 0 360 220');
                this.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            }

            render() {
                if (!this.svg) return;
                this.svg.innerHTML = '';
                this.renderEdges();
                this.renderNodes();
            }

            renderEdges() {
                const edges = this.graph.getEdges();
                const nodes = this.graph.getNodes();
                const nodeMap = new Map(nodes.map(node => [node.id, node]));

                edges.forEach(edge => {
                    const fromNode = nodeMap.get(edge.from);
                    const toNode = nodeMap.get(edge.to);
                    
                    if (fromNode && toNode) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', fromNode.x);
                        line.setAttribute('y1', fromNode.y);
                        line.setAttribute('x2', toNode.x);
                        line.setAttribute('y2', toNode.y);
                        line.setAttribute('class', 'graph-edge');
                        this.svg.appendChild(line);
                    }
                });
            }

            renderNodes() {
                const nodes = this.graph.getNodes();

                nodes.forEach(node => {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'graph-node');

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', node.x);
                    circle.setAttribute('cy', node.y);
                    circle.setAttribute('r', '20');
                    circle.setAttribute('class', 'node-circle');

                    if (node.current) circle.classList.add('current');
                    else if (node.visited) circle.classList.add('visited');
                    else if (node.inQueue) circle.classList.add('in-queue');

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x);
                    text.setAttribute('y', node.y);
                    text.setAttribute('class', 'node-text');
                    text.textContent = node.label;

                    if (node.current) text.classList.add('current');
                    else if (node.visited) text.classList.add('visited');
                    else if (node.inQueue) text.classList.add('in-queue');

                    group.appendChild(circle);
                    group.appendChild(text);
                    this.svg.appendChild(group);
                });
            }
        }

        class TestQueueRenderer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.itemsContainer = this.container?.querySelector('.queue-items');
            }

            updateQueue(queue) {
                if (!this.itemsContainer) return;
                this.itemsContainer.innerHTML = '';

                queue.forEach((item, index) => {
                    const queueItem = document.createElement('div');
                    queueItem.className = 'queue-item';
                    queueItem.textContent = item;
                    if (index === 0) queueItem.classList.add('front');
                    this.itemsContainer.appendChild(queueItem);
                });

                if (queue.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.textContent = 'ä½‡åˆ—ç‚ºç©º';
                    emptyMsg.style.color = '#999';
                    emptyMsg.style.fontStyle = 'italic';
                    this.itemsContainer.appendChild(emptyMsg);
                }
            }

            clear() {
                this.updateQueue([]);
            }
        }

        // ç•¶é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–æ¸¬è©¦
        document.addEventListener('DOMContentLoaded', function() {
            try {
                log('DOM è¼‰å…¥å®Œæˆï¼Œé–‹å§‹åˆå§‹åŒ–...');
                window.testUI = new TestUI();
                log('ğŸ‰ æ¸¬è©¦ç’°å¢ƒåˆå§‹åŒ–æˆåŠŸï¼æ–°æŠ•å½±ç‰‡ä½ˆå±€å·²æ‡‰ç”¨');
                log('ğŸ“ æç¤ºï¼šè§€å¯Ÿç¯€é»æ¨™ç±¤å¦‚ä½•æŒ‰ç…§BFSè¨ªå•é †åºå‹•æ…‹å‡ºç¾');
            } catch (error) {
                log(`ğŸ’¥ åˆå§‹åŒ–å¤±æ•—: ${error.message}`);
                console.error('åˆå§‹åŒ–å¤±æ•—:', error);
            }
        });
    </script>
</body>
</html>